package com.knol.core.impl
import java.sql.Connection._
import java.sql.SQLException._
import com.knol.core.KnolderDao
import com.knol.db.connection.DBConnection
import com.knol.db.connection.DBConnectionImpl
import java.sql.PreparedStatement
import java.sql.Statement
import java.sql.ResultSet
import com.knol.db.connection.DBConnectionImpl
import com.knol.core.KnolderDao
import org.slf4j.LoggerFactory
import com.knol.db.connection.DBConnectionImpl

/*
 * KnolderDaoImpl has 5 functions implemented that are
 * declared in the KnolderDao Trait
 */

class KnolderDaoImpl extends DBConnectionImpl with KnolderDao {
  /*
   * Insert function is used here to insert the data in the table
   * named knolder and returning Option[Int] it has another joined statement
   * that returns the last inserted id (autogenerated)
   */
  /*
  def testCon(): Int = {
    val conImpl = new DBConnectionImpl()
    val con = conImpl.getConnection()
    con match {
      case Some(con) =>
        1
      case None => throw new Exception
    }
  }
*/
  def insert(knol: Knolder): Int =
    {
      val jdb = new DBConnectionImpl()
      val connection = jdb.getConnection()
      connection match {
        case Some(connection) =>
          try {
            val sql = "insert into knolder values(null,'" + knol.name + "','" + knol.email + "','" + knol.mobile + "')"
            val stm = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            val RES = stm.executeUpdate()
            val res = stm.getGeneratedKeys
            res.next()
            val NEWID = res.getInt(1)
            logger.debug("Created ID: " + NEWID + ", result got=" + RES)
            NEWID
          } catch {
            case ex: Exception =>
              logger.error("Coud not create")
              0
          }
        case None => throw new Exception()
      }
    }

  /*
   * Delete function is deleting a row from the knolder table [nikhil] DB,
   * its taking id as parameter and deleting when matched
   */
  def delete(id: Int): Option[Int] =
    {
      val jdb = new DBConnectionImpl()
      val connection = jdb.getConnection()
      connection match {
        case Some(connection) =>
          {
            try {
              val sql = "delete from knolder where id=" + id
              val stm = connection.createStatement()
              val RETURN = stm.executeUpdate(sql)
              logger.debug("Delete successful: " + RETURN)
              require(RETURN == 1)
              Some(RETURN)
            } catch {
              case ee: Exception => {
                logger.error("error in creating", ee)
                None
              }
            }
          }
        case None => None
      }
    }
  /*
   * selectById function is selecting a particular knolder on the basis
   * of passed id as paramenter in the function, knolder table [nikhil DB]
   */
  def selectById(id: Int): Option[Knolder] =
    {
      val jdb = new DBConnectionImpl()
      try {
        val connection = jdb.getConnection()
        connection match {
          case Some(connection) =>
            {
              logger.debug("Connection established successfully")
              val sql = "select id, name, email, mobile from knolder where id=" + id;
              val stm = connection.createStatement()
              val rs = stm.executeQuery(sql);
              rs.next();
              val knol = Knolder(id, rs.getString("name"), rs.getString("email"), rs.getString("mobile"));
              Some(knol)
            }
          case None => None
        }
      } catch {
        case ee: Exception =>
          {
            logger.error("Error in seleting a knol", ee)
            None
          }
      }
    }

  /*
   * update function is used to update the details of particular
   * knolder on the basis of passed id as parameter in the function
   * knolder table [nikhil DB]
   */
  def update(knol: Knolder): Option[Int] =
    {
      val jdb = new DBConnectionImpl()
      try {
        val connection = jdb.getConnection()
        connection match {
          case Some(connection) =>
            {
              val sql = "update knolder set name='" + knol.name + "',email='" + knol.email + "',mobile='" + knol.mobile + "' where id = " + knol.id;
              val stm = connection.createStatement()
              val stmmt = stm.executeUpdate(sql)
              require(stmmt > 0)
              Some(1)
            }
          case None => None
        }
      } catch {
        case ee: Exception =>
          {
            logger.error("Error in deleting a knol", ee)
            None
          }
      }
    }

  /*
   * ShowAll function is returning List of all the knolders from the table
   * knolder, its using PreparedStatement, and showing complete record that is
   * in the knolder table [nikhil DB]
   */
  /*
  def ShowAll: List[Knolder] =
    {
      val jdb = new DBConnectionImpl()
      import scala.collection.mutable;
      var list = List[Knolder]();
      try {
        val connection = jdb.getConnection()
        connection match {
          case Some(connection) => {
            val preparedStatement: PreparedStatement = connection.prepareStatement("SELECT * FROM knolder");
            val resultSet: ResultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
              var knol = Knolder(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getString("email"), resultSet.getString("mobile"));
              list = list.::(knol)
            }
            list
          }
          case None => throw new Exception()
        }
      } catch {
        case ee: Exception =>
          {
            ee.printStackTrace();
            logger.error("Error while showing all knolders", ee)
          }
          list
      }
    }
    * 
    */
}
